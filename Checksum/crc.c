#include <stdio.h>
#include <string.h>
#include "stdafx.h"
#include "crc.h"
#include "stm32f4xx.h"
#include "MW_Misc.h"

#define CRC16_POLY  0xA001 /* 0x8005 */
#define CRC32_POLY  0x4C11DB7      // STM32f4


#ifdef CRC32_SW
static unsigned long lCrc32 = 0xffffffff;
static unsigned long lpCrc32Table[256];  
static unsigned char lCrc32TableInit = 0;
#endif // CRC32_SW

uint8_t GetLRC (const void* apBuff, size_t len)
{
	uint8_t ret = 0;
	uint32_t i;
	for (i = 0; i < len; ++i)
		ret = ret ^ ((uint8_t *)apBuff)[i];
	return ret;
}

uint16_t update_crc_16 (uint16_t crc, char data)
{
    int i;
 
	crc ^= data & 0x00ff;
 	for (i = 0; i < 8; i++ )
		if (crc & 0x0001)	crc = ( crc >> 1 ) ^ CRC16_POLY;
		else				crc = ( crc >> 1 );
 
    return crc;
}

uint16_t crc16_calc(uint16_t crc, unsigned char * buff, int len)
{
	int i;
	
	for (i=0;i<len;i++)
	{
		crc = update_crc_16(crc,buff[i]);
	}
	return crc;
}


// –асчет CRC8 дл€ протокола —каута (полином x^8 + x^7 + x^4 + x^0)
// начальное значение crc = 0xFF
uint8_t Scout_update_crc8 (uint8_t crc, uint8_t data)
{
	static const uint8_t CRC8Table[256] = {
		0x00,0x91,0xE3,0x72,0x07,0x96,0xE4,0x75,0x0E,0x9F,0xED,0x7C,0x09,0x98,0xEA,0x7B,
		0x1C,0x8D,0xFF,0x6E,0x1B,0x8A,0xF8,0x69,0x12,0x83,0xF1,0x60,0x15,0x84,0xF6,0x67,
		0x38,0xA9,0xDB,0x4A,0x3F,0xAE,0xDC,0x4D,0x36,0xA7,0xD5,0x44,0x31,0xA0,0xD2,0x43,
		0x24,0xB5,0xC7,0x56,0x23,0xB2,0xC0,0x51,0x2A,0xBB,0xC9,0x58,0x2D,0xBC,0xCE,0x5F,
		0x70,0xE1,0x93,0x02,0x77,0xE6,0x94,0x05,0x7E,0xEF,0x9D,0x0C,0x79,0xE8,0x9A,0x0B,
		0x6C,0xFD,0x8F,0x1E,0x6B,0xFA,0x88,0x19,0x62,0xF3,0x81,0x10,0x65,0xF4,0x86,0x17,
		0x48,0xD9,0xAB,0x3A,0x4F,0xDE,0xAC,0x3D,0x46,0xD7,0xA5,0x34,0x41,0xD0,0xA2,0x33,
		0x54,0xC5,0xB7,0x26,0x53,0xC2,0xB0,0x21,0x5A,0xCB,0xB9,0x28,0x5D,0xCC,0xBE,0x2F,
		0xE0,0x71,0x03,0x92,0xE7,0x76,0x04,0x95,0xEE,0x7F,0x0D,0x9C,0xE9,0x78,0x0A,0x9B,
		0xFC,0x6D,0x1F,0x8E,0xFB,0x6A,0x18,0x89,0xF2,0x63,0x11,0x80,0xF5,0x64,0x16,0x87,
		0xD8,0x49,0x3B,0xAA,0xDF,0x4E,0x3C,0xAD,0xD6,0x47,0x35,0xA4,0xD1,0x40,0x32,0xA3,
		0xC4,0x55,0x27,0xB6,0xC3,0x52,0x20,0xB1,0xCA,0x5B,0x29,0xB8,0xCD,0x5C,0x2E,0xBF,
		0x90,0x01,0x73,0xE2,0x97,0x06,0x74,0xE5,0x9E,0x0F,0x7D,0xEC,0x99,0x08,0x7A,0xEB,
		0x8C,0x1D,0x6F,0xFE,0x8B,0x1A,0x68,0xF9,0x82,0x13,0x61,0xF0,0x85,0x14,0x66,0xF7,
		0xA8,0x39,0x4B,0xDA,0xAF,0x3E,0x4C,0xDD,0xA6,0x37,0x45,0xD4,0xA1,0x30,0x42,0xD3,
		0xB4,0x25,0x57,0xC6,0xB3,0x22,0x50,0xC1,0xBA,0x2B,0x59,0xC8,0xBD,0x2C,0x5E,0xCF
	};

	return CRC8Table[crc ^ data];
}


// табличное вычисление CRC8 с полиномом 0xD5
uint8_t update_crc8 (uint8_t crc, uint8_t data)
{
	static const uint8_t crc8_table[256] = {
		0x00, 0xD5, 0x7F, 0xAA, 0xFE, 0x2B, 0x81, 0x54, 0x29, 0xFC, 0x56, 0x83, 0xD7, 0x02, 0xA8, 0x7D,
		0x52, 0x87, 0x2D, 0xF8, 0xAC, 0x79, 0xD3, 0x06, 0x7B, 0xAE, 0x04, 0xD1, 0x85, 0x50, 0xFA, 0x2F,
		0xA4, 0x71, 0xDB, 0x0E, 0x5A, 0x8F, 0x25, 0xF0, 0x8D, 0x58, 0xF2, 0x27, 0x73, 0xA6, 0x0C, 0xD9,
		0xF6, 0x23, 0x89, 0x5C, 0x08, 0xDD, 0x77, 0xA2, 0xDF, 0x0A, 0xA0, 0x75, 0x21, 0xF4, 0x5E, 0x8B,
		0x9D, 0x48, 0xE2, 0x37, 0x63, 0xB6, 0x1C, 0xC9, 0xB4, 0x61, 0xCB, 0x1E, 0x4A, 0x9F, 0x35, 0xE0,
		0xCF, 0x1A, 0xB0, 0x65, 0x31, 0xE4, 0x4E, 0x9B, 0xE6, 0x33, 0x99, 0x4C, 0x18, 0xCD, 0x67, 0xB2,
		0x39, 0xEC, 0x46, 0x93, 0xC7, 0x12, 0xB8, 0x6D, 0x10, 0xC5, 0x6F, 0xBA, 0xEE, 0x3B, 0x91, 0x44,
		0x6B, 0xBE, 0x14, 0xC1, 0x95, 0x40, 0xEA, 0x3F, 0x42, 0x97, 0x3D, 0xE8, 0xBC, 0x69, 0xC3, 0x16,
		0xEF, 0x3A, 0x90, 0x45, 0x11, 0xC4, 0x6E, 0xBB, 0xC6, 0x13, 0xB9, 0x6C, 0x38, 0xED, 0x47, 0x92,
		0xBD, 0x68, 0xC2, 0x17, 0x43, 0x96, 0x3C, 0xE9, 0x94, 0x41, 0xEB, 0x3E, 0x6A, 0xBF, 0x15, 0xC0,
		0x4B, 0x9E, 0x34, 0xE1, 0xB5, 0x60, 0xCA, 0x1F, 0x62, 0xB7, 0x1D, 0xC8, 0x9C, 0x49, 0xE3, 0x36,
		0x19, 0xCC, 0x66, 0xB3, 0xE7, 0x32, 0x98, 0x4D, 0x30, 0xE5, 0x4F, 0x9A, 0xCE, 0x1B, 0xB1, 0x64,
		0x72, 0xA7, 0x0D, 0xD8, 0x8C, 0x59, 0xF3, 0x26, 0x5B, 0x8E, 0x24, 0xF1, 0xA5, 0x70, 0xDA, 0x0F,
		0x20, 0xF5, 0x5F, 0x8A, 0xDE, 0x0B, 0xA1, 0x74, 0x09, 0xDC, 0x76, 0xA3, 0xF7, 0x22, 0x88, 0x5D,
		0xD6, 0x03, 0xA9, 0x7C, 0x28, 0xFD, 0x57, 0x82, 0xFF, 0x2A, 0x80, 0x55, 0x01, 0xD4, 0x7E, 0xAB,
		0x84, 0x51, 0xFB, 0x2E, 0x7A, 0xAF, 0x05, 0xD0, 0xAD, 0x78, 0xD2, 0x07, 0x53, 0x86, 0x2C, 0xF9
	};

    return crc8_table[data ^ crc];
}



void Crc32GetTable() 
{	
	// make CRC lookup table used by table algorithms
#ifdef CRC32_SW
	int i, j;
	unsigned long bit, crc;

	for (i=0; i<256; i++) 
	{
		crc=(unsigned long)i;

		crc<<= 32-8;

		for (j=0; j<8; j++) 
		{
			bit = crc & 0x80000000;
			crc<<= 1;
			if (bit) crc^= CRC32_POLY;
		}			

		crc &= 0xFFFFFFFF;
		lpCrc32Table[i]= crc;
	}  
#endif // CRC32_SW

}


TCrc32 Crc32Reset(void)
{
#ifndef CRC32_SW
	CRC->IDR = CRC_IDR_IDR;
	CRC->CR = CRC_CR_RESET;  
	return  (CRC->DR);
#else
	lCrc32 = 0xFFFFFFFF;

	if(!lCrc32TableInit)
		Crc32GetTable();

	return lCrc32;
#endif
}

#ifndef CRC32_SW
	#define Crc32Calc(val)	CRC->DR = val
#else
static void Crc32Calc (TCrc32 aValue)
{
	unsigned long temp = SWAP32(aValue);
	unsigned char* tpTemp = (unsigned char*)&temp;
	int i;

	for (i = 0; i < 4; i++) 
	{
		lCrc32 = (lCrc32 << 8) ^ lpCrc32Table[ ((lCrc32 >> (32-8)) & 0xff) ^ *tpTemp++];
	}
}
#endif

TCrc32 Crc32CalcBlock (const void *apData, size_t aLength)
{
	unsigned long *tpData = (unsigned long *)apData;
	uint32_t tIdx;

	for(tIdx = 0; tIdx < aLength/4; ++tIdx)
	{
		Crc32Calc(*tpData++);
	}

	if(aLength %4)
	{
		unsigned long temp = 0;
		memcpy(&temp, tpData, aLength %4);
		Crc32Calc(temp);
	}

#ifndef CRC32_SW
	return CRC->DR;
#else
	return(lCrc32);
#endif
}


/* скрипт формировани€ таблички

#!/usr/bin/python
# -*- coding: utf-8 -*-

poly = 0xD5
crc_table = []

for n in xrange(256):
    ch = n

    for k in xrange(8):
        if (ch & 0x80):
            ch = (ch << 1) ^ poly
        else:
            ch = (ch << 1)
        ch = ch & 0xFF

    crc_table.append (ch)

print 'const uint8_t crc_table[256] = {',
for n in xrange(256):
    if not (n % 16):
        print
    print '0x{:02X},'.format (crc_table[n]),
print '};\n\n'


*/

